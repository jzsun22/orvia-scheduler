'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { supabase } from '../../../lib/supabase/client';
import { generateWeeklySchedule } from '@/lib/scheduling/scheduleGenerator';

interface Location {
  id: string;
  name: string;
}

interface Worker {
  id: string;
  first_name: string;
  last_name: string;
  preferred_name?: string | null;
}

interface Position {
  id: string;
  name: string;
  is_recurring_generated?: boolean;
  positionName?: string;
  workerName?: string;
  location_id?: string;
}

interface ShiftTemplate {
  id: string;
  location_id: string;
  position_id: string;
  days_of_week: string[]; // e.g., ["monday", "tuesday"] lowercase
  start_time: string; // "HH:MM:SS"
  end_time: string;   // "HH:MM:SS"
}

interface ScheduledShift {
  id: string; // This would be generated by Supabase on insert
  shift_date: string; // "YYYY-MM-DD"
  template_id: string;
  worker_id: string | null;
  start_time: string; // "HH:MM:SS"
  end_time: string;   // "HH:MM:SS"
  is_recurring_generated: boolean;
  positionName?: string;
  workerName?: string;
  location_id?: string;
}

interface RecurringShiftAssignment {
  id: string;
  worker_id: string;
  position_id: string;
  location_id: string;
  day_of_week: string; // e.g., "monday", "tuesday"
  start_time: string; // "HH:MM:SS"
  end_time: string;   // "HH:MM:SS"
}

interface ErrorLogEntry {
  timestamp: string;
  message: string;
  type: 'INFO' | 'ERROR' | 'SUCCESS';
  context?: string;
}

const LOCATION_NAMES = {
  SUNNYVALE: 'Sunnyvale',
  CUPERTINO: 'Cupertino',
};

const ScheduleGenerationTestPage: React.FC = () => {
  const [locations, setLocations] = useState<Location[]>([]);
  const [positions, setPositions] = useState<Position[]>([]);
  const [allShiftTemplates, setAllShiftTemplates] = useState<ShiftTemplate[]>([]);
  const [allRecurringAssignments, setAllRecurringAssignments] = useState<RecurringShiftAssignment[]>([]);
  const [allWorkers, setAllWorkers] = useState<Worker[]>([]);
  
  const [sunnyvaleSchedule, setSunnyvaleSchedule] = useState<ScheduledShift[]>([]);
  const [cupertinoSchedule, setCupertinoSchedule] = useState<ScheduledShift[]>([]);
  
  const [logs, setLogs] = useState<ErrorLogEntry[]>([]);
  
  const [loadingStates, setLoadingStates] = useState<{[key: string]: boolean}>({});

  const addLog = useCallback((message: string, type: ErrorLogEntry['type'], context?: string) => {
    setLogs(prevLogs => [
      { timestamp: new Date().toISOString(), message, type, context },
      ...prevLogs,
    ]);
  }, []);

  useEffect(() => {
    const fetchInitialData = async () => {
      try {
        addLog('Fetching initial data (locations, positions, templates, recurring assignments)...', 'INFO');
        // @ts-ignore
        const { data: locData, error: locError } = await supabase.from('locations').select('id, name');
        if (locError) throw locError;
        setLocations(locData || []);

        // @ts-ignore
        const { data: workerData, error: workerError } = await supabase.from('workers').select('id, first_name, last_name, preferred_name');
        if (workerError) throw workerError;
        setAllWorkers(workerData || []);

        // @ts-ignore
        const { data: posData, error: posError } = await supabase.from('positions').select('id, name');
        if (posError) throw posError;
        setPositions(posData || []);

        // @ts-ignore
        const { data: templateData, error: templateError } = await supabase.from('shift_templates').select('*');
        if (templateError) throw templateError;
        setAllShiftTemplates(templateData || []);

        // @ts-ignore
        const { data: rsaData, error: rsaError } = await supabase.from('recurring_shift_assignments').select('*');
        if (rsaError) throw rsaError;
        setAllRecurringAssignments(rsaData || []);

        addLog('Initial data fetched successfully.', 'SUCCESS');
      } catch (error: any) {
        addLog(`Error fetching initial data: ${error.message}`, 'ERROR');
      }
    };
    fetchInitialData();
  }, [addLog]);

  const getNextWeekDates = (): { startDate: string, endDate: string, weekMap: Map<string, string> } => {
    const today = new Date();
    const dayOfWeek = today.getDay(); // 0 (Sun) - 6 (Sat)
    
    const nextMonday = new Date(today);
    nextMonday.setDate(today.getDate() + (dayOfWeek === 0 ? 1 : 8 - dayOfWeek));
    nextMonday.setHours(0, 0, 0, 0);

    const weekDates: Date[] = [];
    const weekMap = new Map<string, string>();
    const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];

    for (let i = 0; i < 7; i++) {
      const currentDate = new Date(nextMonday);
      currentDate.setDate(nextMonday.getDate() + i);
      weekDates.push(currentDate);
      const dayName = dayNames[currentDate.getDay()];
      weekMap.set(dayName, currentDate.toISOString().split('T')[0]);
    }
    
    const startDate = weekDates[0].toISOString().split('T')[0];
    const endDate = weekDates[6].toISOString().split('T')[0];
    
    return { startDate, endDate, weekMap };
  };
  
  const formatTime = (timeStr: string) => { // HH:MM:SS or HH:MM
    if (!timeStr) return 'N/A';
    return timeStr.substring(0, 5);
  }

  const getPositionName = useCallback((positionId: string): string => {
    const position = positions.find(p => p.id === positionId);
    return position ? position.name : 'Unknown Position';
  }, [positions]);

  const getWorkerName = useCallback((workerId: string | null): string => {
    if (!workerId) return 'Unassigned';
    const worker = allWorkers.find(w => w.id === workerId);
    if (!worker) return 'Unknown Worker';
    return worker.preferred_name || `${worker.first_name} ${worker.last_name}`;
  }, [allWorkers]);

  const enrichScheduledShifts = useCallback((shifts: ScheduledShift[]): ScheduledShift[] => {
    return shifts.map(shift => ({
      ...shift,
      positionName: shift.template_id 
        ? getPositionName(allShiftTemplates.find(st => st.id === shift.template_id)?.position_id || '') 
        : 'N/A',
      workerName: getWorkerName(shift.worker_id),
    }));
  }, [allShiftTemplates, getPositionName, getWorkerName]);

  const fetchScheduledShiftsForLocation = async (locationId: string, startDate: string, endDate: string): Promise<ScheduledShift[]> => {
    // This query needs to join through shift_templates to filter by location_id
    // For simplicity in this mock, we assume scheduled_shifts might have location_id or we filter client-side
    // A real query:
    // const { data, error } = await supabase
    //   .from('scheduled_shifts')
    //   .select('*, shift_templates!inner(location_id)')
    //   .eq('shift_templates.location_id', locationId)
    //   .gte('shift_date', startDate)
    //   .lte('shift_date', endDate);

    // @ts-ignore
    const { data, error } = await supabase
      .from('scheduled_shifts')
      .select('*')
      // .eq('location_id', locationId) // This column doesn't exist on scheduled_shifts
      .gte('shift_date', startDate)
      .lte('shift_date', endDate);

    if (error) {
      addLog(`Error fetching schedule for ${locationId}: ${error.message}`, 'ERROR');
      return [];
    }
    
    // Client-side filter for shifts belonging to the location via templates
    const locationTemplates = allShiftTemplates.filter(st => st.location_id === locationId).map(st => st.id);
    const filteredData = (data || []).filter((s: ScheduledShift) => s.template_id && locationTemplates.includes(s.template_id));

    return enrichScheduledShifts(filteredData as ScheduledShift[]);
  };

  const handleGenerateSchedule = async (locationName: string) => {
    const location = locations.find(l => l.name === locationName);
    if (!location) {
      addLog(`Location ${locationName} not found.`, 'ERROR');
      return;
    }
    const locationId = location.id;
    const loadingKey = `generate-${locationId}`;
    setLoadingStates(prev => ({ ...prev, [loadingKey]: true }));
    addLog(`Generating schedule for ${locationName}...`, 'INFO', locationName);

    const { startDate, endDate, weekMap } = getNextWeekDates();

    if (!confirm(`This will delete any existing shifts for ${locationName} from ${startDate} to ${endDate} and generate new ones. Continue?`)) {
      addLog('Schedule generation cancelled by user.', 'INFO', locationName);
      setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
      return;
    }

    // Declare generationResult here to be in scope for the summary log
    let generationResult: { success: boolean; warnings?: string[]; unassignedSlots?: ShiftTemplate[] } | undefined;

    try {
      // 1. Delete existing shifts for the location and week
      addLog(`Deleting existing shifts for ${locationName} (${startDate} - ${endDate})...`, 'INFO', locationName);
      const templatesForLocation = allShiftTemplates.filter(st => st.location_id === locationId);
      if (templatesForLocation.length === 0) {
          addLog(`No shift templates found for ${locationName}. Cannot delete or generate shifts.`, 'ERROR', locationName);
          setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
          return;
      }
      const templateIdsForLocation = templatesForLocation.map(t => t.id);

      // @ts-ignore
      const { error: deleteError } = await supabase
        .from('scheduled_shifts')
        .delete()
        // @ts-ignore
        .in('template_id', templateIdsForLocation)
        .gte('shift_date', startDate)
        .lte('shift_date', endDate);

      if (deleteError) throw new Error(`Failed to delete existing shifts: ${deleteError.message}`);
      addLog('Existing shifts deleted successfully.', 'SUCCESS', locationName);

      // 2. Call the main schedule generator from the library
      addLog(`Calling core schedule generator for ${locationName} (week of ${startDate})...`, 'INFO', locationName);
      try {
        // Assign to the outer scope variable
        generationResult = await generateWeeklySchedule(
          locationId,       
          new Date(startDate) 
        );

        addLog(
          `Core generator finished for ${locationName}. Success: ${generationResult.success}. Warnings: ${generationResult.warnings?.join(', ')}`,
          generationResult.success ? 'SUCCESS' : 'ERROR',
          locationName
        );

      } catch (genError: any) { 
        addLog(`Error during core schedule generation for ${locationName}: ${genError.message}`, 'ERROR', locationName);
        setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
        return;
      }

      // 3. Fetch and display the new schedule
      const updatedSchedule = await fetchScheduledShiftsForLocation(locationId, startDate, endDate);
      if (locationName === LOCATION_NAMES.SUNNYVALE) setSunnyvaleSchedule(updatedSchedule);
      if (locationName === LOCATION_NAMES.CUPERTINO) setCupertinoSchedule(updatedSchedule);

      // Log detailed summary after fetching the actual generated schedule
      if (generationResult && generationResult.success) { 
        const locationSpecificTemplates = allShiftTemplates.filter(st => st.location_id === locationId);
        const totalExpectedInstances = locationSpecificTemplates.reduce((sum, t) => sum + t.days_of_week.length, 0);
        
        const filledInstances = updatedSchedule.length; 
        const unfilledInstances = totalExpectedInstances - filledInstances;

        const summaryMessage = `Schedule Generation Summary for ${locationName}: Total expected template instances: ${totalExpectedInstances}. Filled instances: ${filledInstances}. Unfilled instances: ${unfilledInstances}.`;
        addLog(summaryMessage, 'INFO', locationName);
      }

    } catch (error: any) { // This is the main catch for handleGenerateSchedule (e.g., for deletion error)
      addLog(`Error generating schedule for ${locationName}: ${error.message}`, 'ERROR', locationName);
    } finally {
      setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
    }
  };

  const handleDeleteSchedule = async (locationName: string) => {
    const location = locations.find(l => l.name === locationName);
    if (!location) {
      addLog(`Location ${locationName} not found.`, 'ERROR');
      return;
    }
    const locationId = location.id;
    const loadingKey = `delete-${locationId}`;
    setLoadingStates(prev => ({ ...prev, [loadingKey]: true }));
    addLog(`Attempting to delete schedule for ${locationName} (next week)...`, 'INFO', locationName);

    const { startDate, endDate } = getNextWeekDates();

    if (!confirm(`Are you sure you want to delete all scheduled shifts for ${locationName} from ${startDate} to ${endDate}?`)) {
      addLog('Schedule deletion cancelled by user.', 'INFO', locationName);
      setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
      return;
    }
    
    try {
      const templatesForLocation = allShiftTemplates.filter(st => st.location_id === locationId);
      if (templatesForLocation.length === 0) {
          addLog(`No shift templates found for ${locationName}. Cannot identify shifts to delete.`, 'ERROR', locationName);
          setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
          return;
      }
      const templateIdsForLocation = templatesForLocation.map(t => t.id);

      // @ts-ignore
      const { error: deleteError } = await supabase
        .from('scheduled_shifts')
        .delete()
        // @ts-ignore
        .in('template_id', templateIdsForLocation)
        .gte('shift_date', startDate)
        .lte('shift_date', endDate);

      if (deleteError) throw new Error(`Failed to delete schedule: ${deleteError.message}`);
      
      addLog(`Schedule for ${locationName} (${startDate} - ${endDate}) deleted successfully.`, 'SUCCESS', locationName);
      if (locationName === LOCATION_NAMES.SUNNYVALE) setSunnyvaleSchedule([]);
      if (locationName === LOCATION_NAMES.CUPERTINO) setCupertinoSchedule([]);

    } catch (error: any) {
      addLog(`Error deleting schedule for ${locationName}: ${error.message}`, 'ERROR', locationName);
    } finally {
      setLoadingStates(prev => ({ ...prev, [loadingKey]: false }));
    }
  };

  const handleClearLog = () => setLogs([]);

  const renderScheduleTable = (schedule: ScheduledShift[], locationName: string) => {
    if (!schedule.length) return <p>No schedule generated for {locationName} for next week.</p>;
    return (
      <table border={1} style={{ width: '100%', borderCollapse: 'collapse' } as React.CSSProperties}>
        <thead>
          <tr>
            <th>Date</th>
            <th>Start Time</th>
            <th>End Time</th>
            <th>Position</th>
            <th>Assigned Worker</th>
            <th>Recurring Gen.</th>
            <th>Template ID</th>
          </tr>
        </thead>
        <tbody>
          {schedule.map((shift, index) => (
            <tr key={shift.id || index}> {/* Use index as fallback if ID not present yet from mock */}
              <td>{shift.shift_date}</td>
              <td>{formatTime(shift.start_time)}</td>
              <td>{formatTime(shift.end_time)}</td>
              <td>{shift.positionName || 'N/A'}</td>
              <td>{shift.workerName || 'Unassigned'}</td>
              <td>{shift.is_recurring_generated ? 'Yes' : 'No'}</td>
              <td>{shift.template_id}</td>
            </tr>
          ))}
        </tbody>
      </table>
    );
  };

  return (
    <div style={{ padding: '20px', fontFamily: 'sans-serif' } as React.CSSProperties}>
      <h1>Schedule Generation Test Page</h1>

      {[LOCATION_NAMES.SUNNYVALE, LOCATION_NAMES.CUPERTINO].map(locationName => {
        const location = locations.find(l => l.name === locationName);
        const locationId = location?.id || locationName.toLowerCase();
        const schedule = locationName === LOCATION_NAMES.SUNNYVALE ? sunnyvaleSchedule : cupertinoSchedule;
        
        return (
          <section key={locationName} style={{ marginBottom: '30px', padding: '15px', border: '1px solid #eee' } as React.CSSProperties}>
            <h2>{locationName} Controls & Schedule</h2>
            <div style={{ marginBottom: '10px' } as React.CSSProperties}>
              <button 
                onClick={() => handleGenerateSchedule(locationName)}
                disabled={loadingStates[`generate-${locationId}`]}
                className={`px-4 py-2 rounded-md font-medium text-white bg-green-600 hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed mr-4 transition-colors`}
              >
                {loadingStates[`generate-${locationId}`] ? 'Generating...' : `Generate Schedule for ${locationName} (Next Week)`}
              </button>
              <button
                onClick={() => handleDeleteSchedule(locationName)}
                disabled={loadingStates[`delete-${locationId}`]}
                className={`px-4 py-2 rounded-md font-medium text-white bg-red-600 hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors`}
              >
                {loadingStates[`delete-${locationId}`] ? 'Deleting...' : `Delete Schedule for ${locationName} (Next Week)`}
              </button>
            </div>
            <h3>Next Week's Schedule for {locationName}</h3>
            {renderScheduleTable(schedule, locationName)}
          </section>
        );
      })}

      <section style={{ marginTop: '30px', padding: '15px', border: '1px solid #ccc', background: '#f9f9f9' } as React.CSSProperties}>
        <h2>Generation & Deletion Log</h2>
        <button 
          onClick={handleClearLog} 
          className="px-3 py-1.5 rounded-md font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 transition-colors mb-4"
        >
          Clear Log
        </button>
        {logs.length === 0 && <p>No log entries yet.</p>}
        <ul style={{ listStyleType: 'none', padding: 0, maxHeight: '300px', overflowY: 'auto' } as React.CSSProperties}>
          {logs.map((log, index) => (
            <li key={index} style={{ marginBottom: '5px', padding: '5px', borderBottom: '1px dotted #ddd', color: log.type === 'ERROR' ? 'red' : log.type === 'SUCCESS' ? 'green' : 'black' } as React.CSSProperties}>
              <strong>{log.timestamp}</strong> [{log.type}]{log.context ? ` [${log.context}]` : ''}: {log.message}
            </li>
          ))}
        </ul>
      </section>
    </div>
  );
};

export default ScheduleGenerationTestPage; 